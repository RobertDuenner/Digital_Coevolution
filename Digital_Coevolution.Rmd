---
title: "Digital_Coevolution"
subtitle: "An agent based simulation for host-parasite coevolution"
author: "Robert P. Duenner"
date: '2020-04-27'
output:
  github_document: 
    toc: true
  pdf_document:
    highlight: zenburn
  word_document: 
  html_document: 
    toc: true
    toc_depth: 3
    number_sections: false
    toc_float:  
      collapsed: true
    code_folding: hide
bibliography: My Library.bib
---

```{r, eval = FALSE, echo = FALSE}
library(formatR)
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60)) #,tidy=TRUE)
```

```{r global_options, include=FALSE}
# This can be activated to exclude all R chunks from the final output. I am thinking of something like having the R code in the readme, and not having it in the thesis. Makes things flexible.
#knitr::opts_chunk$set(include = FALSE)
```

\newpage
\tableofcontents
\newpage

# Introduction
Many factors influence the growth of a host population and the infection dynamics with parasites. Each host is an individual that gets born, has to compete for resources and possibly mates, grows, and ideally also reproduces. How well it does all of those is defined as the life history of the host and its trade-offs. The host might also be unlucky and encounter a parasite. If an infection happens is dependent on the genotypes of host and parasite, how specific the infectivity of the parasite is, how many parasites are encountered and how large the host and its infective dose is, how well the constitution of the host and especially the hosts immune system is and so much more. All those factors are a given in wild populations, but many might be unknown and for sure can not be manipulated. The same goes for laboratory populations in micro- or mesocosms.  

The interaction of host and parasite goes way beyond what happens between individual hosts and parasites. All organisms live in populations. Some might be larger, some smaller, some denser, others sparse, some isolated, others very well connected and part of a metapopulation. All those influence the infection dynamics of host and parasite. Larger host populations are less affected by drift and can have a larger genetic diversity, sustaining parasites longer before they burn out. In small populations parasites can degrade genetic polymorphism (see chapter 2). Metapopulation structure on the other hand has a tremendous impact on the coevolution [@Ladle1993; @Lion2015] and the genetic structure of both the host and the parasite [@Judson1995; @Judson1997]. The amount of migrants and the migration distance can influence virulence evolution [@Boots1999; @Boots2007], enable local adaptation of the parasite on the host [@Gandon1996; @Gandon2002; @Gandon2002a] or can even shut down negative frequency dependent selection within subpopulations (see chapter 3).  

It is hard to account for all those factors in the wild, lest find several comparable examples with different parameters that would allow for fine tuned hypothesis testing. It is still hard to get conditions right for laboratory populations to sustain infection in just the right way, a process that can absorb more time than the actual experiment itself. And establishing sizeable metapopulations are a logistical challenge.  
Simulations can help with that. 

Invaluable insight into most areas of host parasite coevolution has been gained by simulation studies or theoretical models (see all citations above), including the first hypotheses of parasites as causative agents of negative frequency dependent selection and maintenance of genetic polymorphism [@Haldane1949; @Haldane1963; @Clarke1976; @Clarke1979] as well as sexual reproduction [@Jaenike1978; @Hamilton1980; @Hamilton1990]. The power and capabilities of computer simulations increases steadily with time, as hardware becomes more powerful and software advances. This opens the opportunity to create simulations that try to capture more and more biological realism, trying to make the gap in realism between simulations and laboratory micro- and mesocosms smaller. All models are wrong, but some are useful. A simulation can never be as realistic as the real world, as much as a map can never be the real landscape. But we can try and make the simulation as realistic as possible by trying to include different aspects of a hosts and a parasites life cycle that we deem relevant, trying to enhance the precision and usability of predictions generated by this simulation, much as we can draw more information from a more detailed map.

The goal could be to advance simulations as much as to create digital organisms that recreate key aspects of real world organisms in silico, in order to be able to use those organisms in in-silico experiments that have clear laboratory counterparts. This would make results of simulations directly comparable, and allows for the generation of testable hypotheses. It is also especially handy to explore a variety of different questions in a fast, convenient and cheap manner before trying to establish elaborate and costly experiments.

One area that I deem especially noteworthy in this respect are agent based or individual based models. Those models simulate the behaviour of each individual explicitly, allowing for a great amount of detail. Instead of detailing required properties at the population level, those simulations describe rules for individual behaviour and development. All further higher level dynamcics, for example interaction with other individuals or population or metapopulation behaviour, are then emergent properties of the behaviour of groups of individually simulated agents. 

The Digital_Coevolution simulation script is a digital organism in the sense that it tries to simulate the dynamic behaviour of single organisms in a computer simulation. Population level behaviour emerges from interactions between several of these simulated organisms. This means Digital_Coevolution falls into the category of agent based simulations, a level of simulation exceptionally well suited to study questions in evolutionary biology. It was created initially as a tool to study how metapopulation structure influences coevolutionary dynamics between hosts and parasites, but can be extended to the study of many different questions in host parasite coevolution. 

This document serves as the documentation for the Digital_Coevolution simulation framework. It describes the inner workings and the reasoning behind the Digital_Coevolution simulation and should enable the reader to thoroughly understand and use the simulation. The first part describes the "biological logic" behind the code. It describes the functions that govern the behaviour of the agents in this agent based simulation. The second part then describes the implementation of the Digital_Coevolution, moving from biologial logic towards R logic. The third part finally describes how to use the Digital_Coevolution simulation yourself.  
This document is written in rmarkdown [@Xie2018; @Allaire2020] in R [@RCoreTeam2020] using RStudio [@RStudioTeam2019] as IDE. It consists of blocks of text that are followed by snippets of commented code when appropriate. The text and the comments do show some substantial overlap, trying to reinforce a thourough understanding of what is happening in the simulation. The code snippets are not complete though, and serve mostly as explanations. If you would like to have a look at the complete source code or even contribute, you are very welcome to do so, and I invite you to visit the Digital_Coevolution Github repository of the simulation (in case that isn't where you already are) (cite github repository) or the github repositories of chapter 2 and 3 to see the simulation in action (cite github repositories).  

-------------------------------

\newpage

# Part One: Biological Logic

## Overview
The agents that make up the Digital_Coevolution simulation have quite complex life histories.  
They are born as small individuals with a few resident resources. They compete with conspecifics for resources, and can use those resources to grow. Excess resources can be used to build up a fat storage for harder times. The older an individual grows, the less resources it invests in growth and the more resources it invests in reproduction. Reproduction is implemented as iteroparous clonal capital breeding, so each individual has to save up resources until it can start reproducing, but it can reproduce several times during its lifetime, resources permitting. The age dependent shift of resource investment from growth to reproduction ensures that early in life, the resources invested into reproduction are not sufficient to produce offspring, creating a distinct juvenile phase that is dominated by growth. Later in life, when more resources are invested into reproduction, an individual does not grow substantially, creating an adult life stage that is dominated by reproduction.  
Throughout all life stages a host individual can encounter parasites. Those are ingested haphazardously with food resources, and might establish an infection in an host individual, depending on the number of spores ingested and the respective genotypes of the host individual and the parasites spores. If an infection does establish, it starts small. Infections grow over time, until they fill out the space within a host individual that is available to a parasite, completely. Infections steal resources from the host individual. The amount of resources that a parasite steals is dependent on the size of the infection. Larger infections steal more resources.  
Parasites reproduce in the same mode as the host, as iteroparous clonal capital breeders. But it is not individual parasite agents that reproduce, but the infection within a host individual. The infection within the host acts as the reproducing unit. Infections can only be established by one genotype at a time, htere are no co-infections possible. As soon as an infection has stolen enough resources from a host it will produce a clutch of parasite offsprings that are shed without killing the host.  
Large infections can hence have a huge influence on the parasite population. A young host indiviual that gets infected early with a parasite might thus find its growth hampered or it might find itself being sterilized, as it can not funnel enough resources to reproduction. An older, larger individual that gets infected late might already have had some reproductive output and already have grown larger, but it will also be able to sustain a much larger infection that then produces many parasite spores and fuels the parasite epidemic.  
A parasite will kill its host as soon as the host does not have enough resources left anymore, for example when the fat storage is used up and there are not enough new resources coming in. The infection spreads horizontally, as parasites are passively ingested by host individuals while foraging. This, together with the non - lethal shedding of new parasites by infections, creates a faeco - oral horizontal transmission.  
The epidemics spread horizontally within populations, with host and parasite encounters being random. One should imagine a well mixed population in terms of hosts, resources and also parasite exposure. But there can be more than one population. The Digital_Coevolution simulation allows to specify any number of discrete populations with any population size. Several populations form a metapopulation when there is a distinct migration pattern between the populations. That is why the Digital_Coevolution Simulation also allows to specify any type of migration pattern between the populations. The migration structure can be specified for both the host and the parasite sepparately. This can be used to create complex metapopulation structures through which hosts and parasites, and hence also epidemics, can spread.  

\newpage
## Within agent dynamics
The agents that make up the Digital_Coevolution can best be imagined as small, mobile, aquatic filter feeders, i.e. zooplankters. Of course a simulation can only ever be an approximation of nature, much like a painting is just a picture of reality, but we can try to make the picture look as real as possible. The same thing was tried when programming Digital_Coevolution. Thinking of the agents as zooplankters, for example a Daphnid or a Cyclops, can help with imagining some of the biology that I tried to implement. Throughout the code and the remainder of this document, these agents are called hosts or agents interchangeably.  
During the simulation, each agent moves through different life history stages, competes with conspecifics for resources and gets potentially exposed to parasites. Those parasites are horizontally transmitted, passive dispersing obligate parasites, which might best be imagined as either a bacterial or fungal pathogens (microsporidians for example). Parasite agents are called parasites in the simulation.  
The following part gives an overview over the different functions, called dynamics functions, that govern the behaviour of each agent in the simulation. You could read this as the instructions for the life histories of each individual.  

### Size
Size is one of the central parameters of the Digital_Coevolution simulation. It is based on the biological observation that most organisms grow over their lifetime. Size influences many organismal traits, but especially the interaction with food resources. Larger individuals consume more resources (eat more) but also have a larger metabolic requirement for resources (need more food). This influences several other parameters that are linked either proportionally or with absolute thresholds against an agents size. For example is the feeding rate of an organism and the amount of parasite spores that this organism will acquire directly linked. A larger organism will ingest more parasite spores than a small one.  
A larger organism will also be able to produce more offspring, as it can acquire more resources faster, and the production of one offspring always costs the same.  
Size is not implemented as one single dynamics function, but as a trait (of an agent) that is influencing many other dynamics functions. Size itself is influenced in the metabolism function when resources get allocated between different life history processes. Growth is one of these processes that can get resources. Digital_Coevolution agents are born with size = 1 and then invest resources into growth depending on their age. The younger an individual is, the more resources (proportionally) it will invest into growth as opposed to reproduction. Size can also be switched of by setting the host.size parameter to "OFF", which then skips the growth step and keeps all individuals at size = 1 at all times. This is especially usefull when one would like to compare results to other, less complex, simulations.  

```{r, eval = FALSE}
# Depending on the age of the host, resources are funneled more towards reproduction or 
# more towards growth.
if(host.size == "ON"){
    Host[Alive.Hosts$Is.Alive, Size := 
           Size + (pmin(Reproduction.Allocation * Size, Resource.Work) * (2 / Age))]
}
```

In Digital_Coevolution, only host agents have an individual size trait. Parasite agents on the other hand have no size themselves. The infection whithin the host agents has a size as well. The infection size is limited by the host agent size, smaller individuals can only maintain smaller infections.  

```{r, eval = FALSE}
# First the infection matures.
Host[Alive.Hosts$Is.Alive, Infection.Size := Infection.Size * infection.growth.factor]

Host[Alive.Hosts$Is.Alive, Infection.Size :=  pmin(Infection.Size, Size)]
```

### Age
All things age. The agents in the Digital_Coevolution simulation should be no exception. There is an age variable built into both host and parasite agents. It is a simple integer counter whose value increases by one each timestep. There is an old-age cutoff, esentially creating senescence, implemented as a threshold value for both host and parasite.  

```{r, eval = FALSE}
# Takes the Age vector and adds one everywhere, then truncates by a pre-set threshold.
Host[Alive.Hosts$Is.Alive, Age := Age + 1L]

Host[Alive.Hosts$Is.Alive & Age > age.threshold.host, Alive := 0L]

Parasite[Alive.Parasites$Is.Alive, Age := Age + 1L]

Parasite[Alive.Parasites$Is.Alive & Age > age.threshold.parasite, Alive := 0L]
```

### Host Resources
Every host agent competes with other host agents for a shared pool of finite resources that renew every timestep. Every host will obtain a discrete amount of resources that are dependent on the size of the host and the size of the host population respective to the available food.  
The resource allocation within each agent works as follows. The resource pool within agent is split in three "containers". One container is for incoming (ingested) resources, one for resources that are currently available for the metabolism (digested), and one is for storing excess resources (think fat storage). Any excess resources that are still available metabolically at the beginning of each timestep are moved into the "Resource.Have" container (fat storage). This frees up the "Resource.Work" container (metabolically available resources). It is filled from the "Resource.In" container, where the ingested resources from one time-step earlier are stored, and potentially also from the "Resource.Have" container. This creates a time-lag between ingested and metabolic available resources. Together with the fat storage, this allows agents to feather off variance in resource availability to some extent. The last step is a starving process, which culls all individuals that have less than a set metabolic resource availability threshold.  

```{r, linewidth = 20, eval = FALSE}
# This moves the leftover resources from the resource.work container to the resource.have 
# container. So leftover metabolic resources to the "fat" storage.
Host[Alive.Hosts$Is.Alive, Resource.Have := Resource.Have + Resource.Work]
    
# I will make the resource.have threshhold, so basically the fat content, size dependant. 
# As larger individuals should be able to proportionally store more fat, a qubic increase 
# instead of a linear increase with size migth be applicable.
Host[Alive.Hosts$Is.Alive, Resource.Have := pmin(Resource.Have, (Size ^ 2))]
    
# Then the resource.work (metabolic resource) gets filled by the resource.in container of 
# the last timestep, creating a delay between feeding and availability of energy.
# This part also lets hosts that get less external resources use some stored resources to 
# fill resource.work
Host[Alive.Hosts$Is.Alive, Resource.Work := 
       Resource.In + pmin((round(Size) - Resource.In), Resource.Have)]
Host[Alive.Hosts$Is.Alive, Resource.Have := 
       Resource.Have - pmin((round(Size) - Resource.In), Resource.Have)]
      
# This part removes individuals that have run out of resources (starving). 
Host[Alive.Hosts$Is.Alive & Resource.Work < resource.threshold.host, Alive := 0]
```

### Host Metabolism
The resource dynamics within host agents is based on the resource allocation hypothesis [@Stearns1980]. It assumes that each organism has a certain energy budget which it can alocate to its life history functions like reproduction or growth. This creates trade-offs between different traits or life history strategies.  
Each host has a metabolic resource availability that is a result of the ingested resources a time step before and resources used from the fat storage (see Host Resources explanation). These resources now need to be allocated to different life history traits. In the case of the Digital_Coevolution, there are three life history traits that are directly resource dependent.  
The "Immune.State" is a variable that should integrate the overall maintenance state of the host including its immune system. It is the baseline investment that has to be made by every organism into maintenance of tissue, body temperature, innate immune response etc.. Basically this is the metabolic cost of being alive. It is the first trait that any agent will invest resources in, according to its size and a set immune allocation proportion. The value of "Immune.State" resets every time-step.  
Next the host will invest into reproduction ("Reproduction.Have"), again according to a set reproduction allocation proportion and its size. If the individual has fewer internal resources available than could be maximally invested into reproduction, reproduction simply drains the remaining resources.  
An individual has to grow as well, and depending on the age of the individual, a certain proportion is invested into growth of the "Size" rather than reproduction. This proportion is changing with age, so that younger individuals invest proportionally more into growth instead of reproduction. This creates a dynamic that will have a young individual grow fast without reproducing (juvenile stage) before transitioning to adulthood and investment into reproduction. This size step can also be switched off to create a simulation with agents of constant size instead of agent growth. That way a cross comparison to to other agent based simulations is easier.

```{r, eval = FALSE}
# This part drains resource.work and assigns to immune.state, refreshes every round, so no 
# immune buildup.
Host[Alive.Hosts$Is.Alive, Immune.State := 
       pmin(Immune.Allocation * Size, Resource.Work)] 

Host[Alive.Hosts$Is.Alive, Resource.Work := 
       Resource.Work - pmin(Immune.Allocation * Size, Resource.Work)]
  
Host[Alive.Hosts$Is.Alive, Reproduction.Have := 
       Reproduction.Have + 
       (pmin(Reproduction.Allocation * Size, Resource.Work) * (1 - (2 / Age)))]

# This part drains resource.work and moves to reproduction have, cummultative.
# Depending on the age of the host, resources are funneled more towards reproduction or 
# more towards growth.
if(host.size == "ON"){
  Host[Alive.Hosts$Is.Alive, Size := 
          Size + (pmin(Reproduction.Allocation * Size, Resource.Work) * (2 / Age))]
}

Host[Alive.Hosts$Is.Alive, Resource.Work := 
       Resource.Work - pmin(Reproduction.Allocation * Size, Resource.Work)]
```

### Host Reproduction
Host reproduction is implemented as a capital breeder. Each host individual must accumulate resources until a set threshold in order to produce a batch (a clutch) of offspring. The number of offspring produced is dependent on the available resources and a multiplicative reproduction factor. It is also indirectly dependent on the size of the individual, as larger individuals can obtain more resources.  
It is implememented by first calculating the identities of all host agents that have accumulated enough resources to reproduce. The identities of reproducing agents are replicated multiple times according to the amount of resources available and the reproductive factor, creating a vector that essentially contains one entry per offspring per agent. This vector is then used to copy the "parents" trait values into empty lines of the host agent data.table. All traits like immune and reproductive allocation are hence heritable.

```{r, eval = FALSE}
# First calculates the number of reproducing individuals, and how many offspring each 
# individual should produce.
reproducing.hosts <- Host[, rep(
  .I[Alive.Hosts$Is.Alive & Reproduction.Have > reproduction.threshold.host], 
  times = 
    round(
      Host[Alive.Hosts$Is.Alive & 
             Reproduction.Have > reproduction.threshold.host,Reproduction.Have] - 
        ((reproduction.threshold.host) * reproduction.factor.host)
  )
  ]
    
# If there are reproducing individuals, proceed, otherwise, skip.
# Open if statement.
if (Host[reproducing.hosts, .N] > 0) {
      
  # In the subset of empty (dead) host rows, fill host rows according to the reproducing 
  # hosts.
  Host[Host[, .I[!Alive.Hosts$Is.Alive][seq(Host[reproducing.hosts, .N])]],
         `:=` 
       (Alive = 1L, 
         Host.Replicate = Host[reproducing.hosts, Host.Replicate], 
         Host.Population = Host[reproducing.hosts, Host.Population], 
         Host.Infection.Genotype = NA, 
         Age = 1, 
         Resource.Have = 1, 
         Reproduction.Allocation = Host[reproducing.hosts, Reproduction.Allocation], 
         Immune.Allocation = Host[reproducing.hosts, Immune.Allocation], 
         Immune.Genotype = Host[reproducing.hosts, Immune.Genotype], 
         Resource.In = 1, 
         Resource.Work = 0, 
         Reproduction.Have = 0, 
         Immune.State = Host[reproducing.hosts, Immune.State], 
         Infection.State = 0L, 
         Infection.Size = 0, 
         Parasite.Resources = 0, 
         Host.TempID = NA, 
         Size = 1, 
         Host.Generation = (Host[reproducing.hosts, Host.Generation] + 1L), 
         Origin = Host[reproducing.hosts, Host.Population])
         ]
      
  # Withdraw the resources used for reproduction.
  Host[Alive.Hosts$Is.Alive & Reproduction.Have > reproduction.threshold.host, 
       Reproduction.Have := 
         Reproduction.Have - (round(Reproduction.Have) - reproduction.threshold.host)]

# Close if statement.
}
```

### Infections
This section is about within agent infection dynamics. To read about the spread of an infection in a population and how host agents get exposed to parasites, please refer to the between agent dynamics section.  
Infections are implemented in a quantitative fashion. Meant by that is that infections have a size, the "Infection.Size" trait, within a host agent. The size of an infection defines how much resources get withdrawn from the hosts resource budget towards the infection by the parasite. Virulence is hence implemented as a resource loss to the host agent. Infections all start at size = 1 and then grow at an exponential pace, mimicking natual infection with microparasites. The resources that get withdrawn by the infection can then be used by the parasite to reproduce, visible in the trait "Parasite.Resources".  

```{r, eval = FALSE}
# First the infection matures.
Host[Alive.Hosts$Is.Alive, Infection.Size := Infection.Size * infection.growth.factor]

Host[Alive.Hosts$Is.Alive, Infection.Size := pmin(Infection.Size, Size)]
    
# Then the parasite draws resources, dependant on infection size.
Host[Alive.Hosts$Is.Alive, Parasite.Resources := 
       Parasite.Resources + pmin(Resource.Work, Infection.Size * virulence)]

Host[Alive.Hosts$Is.Alive, Resource.Work := 
       Resource.Work - pmin(Resource.Work, Infection.Size * virulence)]
```

### Parasite Reproduction
The reproduction of the parasite is implemented as a capital breeder as well. This means that the parasite (the infection) must accumulate resources until a set threshold value, upon which a batch of offspring is produced. The threshold value is independent of the infection size, but the amount of offspring produced is proportional to the accumulated resources. As larger infections accumulate more resources faster, larger infections will produce more offspring.  
The implementation is similar to the host agent reproduction, except that to determine which parasite agent can reproduce, the "Parasite.Resources" trait within the host agents has to be checked. Parasites identities of agents that are reproducing are exported to a vector and repeated according to the accumulated resources of the infection and the reproduction factor. This external vector is then used to copy the trait values of the reproducing parasites into empty rows in the parasite data.table.  

```{r, eval = FALSE}
# The first step selects the subset of the host population that is infected and where the 
# infections have accumulated enough resources to reproduce. And then multiplies this 
# subset by the reproduction factor.
reproducing.parasites <- 
  Host[
    ,
    rep(.I[Alive.Hosts$Is.Alive & Parasite.Resources > reproduction.threshold.parasite], 
        times = round(
          Host[Alive.Hosts$Is.Alive & 
                 Parasite.Resources > reproduction.threshold.parasite, 
               Parasite.Resources] - reproduction.threshold.parasite) * 
          reproduction.factor.parasite)]

# If there are reproducing individuals, proceed, otherwise, skip.
# Open if statement.   
if (Host[reproducing.parasites, .N] > 0) {
  
  # This part selects the "dead" rows in the parasite data.table, then calcualtes how  
  # many offsping are produced, and updates the values from the corresponding 
  # host data.table
  Parasite[
    Parasite[, .I[!Alive.Parasites$Is.Alive][seq(Host[reproducing.parasites, .N])]], 
             `:=` 
             (Alive = 1L, 
               Parasite.Replicate = Host[reproducing.parasites, Host.Replicate], 
               Parasite.Population = Host[reproducing.parasites, Host.Population], 
               Parasite.Infection.Genotype = 
                 Host[reproducing.parasites, Host.Infection.Genotype], 
               Attack.Host.TempID = NA, 
               Attack.Host.Genotype = NA, 
               Success.Parasite.Infection.Genotype = NA, 
               Ingested = 0, 
               Age = 1L)
               ]
  
  Host[Alive.Hosts$Is.Alive & Parasite.Resources > reproduction.threshold.parasite, 
       Parasite.Resources := 
         Parasite.Resources - 
         (round(Parasite.Resources) - reproduction.threshold.parasite)]

  # Uptdate parasite alive vector
  set(Alive.Parasites, j = "Is.Alive", value = Parasite[, Alive == 1])

# Close if statement.    
} 
```

## Between agent dynamics
A great benefit of agent based simulations is that between agent interaction dynamics can be observed at the interaction level. When we think of the agents in the Digital_Coevolution simulation as zooplankters, then we should think of a distinct group of agents as a population. When I wrote this simulation I had not a natural population of zooplankters in mind, but a laboratory population. Think of a glas jar with some media and a few daphnia in it. Environmental conditions are fairly stable (and are hence largely ignored in the simulation, sorry), once a day there is food, and that's about it. With limited amount of medium available to filter feeding zooplankters, a large enough population can potentialy "overfilter" the available media volume. This affects interaction with parasite agents as well, as they can be thought of as being suspended in the same media volume as the food particles. As they are passively ingested with food consumption, resource and parasite epidemiological dynamics are closely linked.  

### Host Resources Population Wide
The host resources are implemented as batch resources per population that renew every timestep. Think of a daily feeding event for a Daphnia culture for example. The hosts then compete for a part of those resources. In order to avoid infinitely small resource consumption, resources are partitioned out in a poisson or quasipoisson distributed way. Each timestep there is a random poisson (or quasipoisson) vector calculated, with one element per host. As the amount of resources available per host is dependent on the population size and the summed-up filtering capacity of the host individuals, the expected mean of the distribution is proportional to the fraction of total filtering capacity per individual. This fraction is calculated by dividing the host individuals' size (equal its filtering capacity) by the sum of sizes over the population, and that fraction is multiplied by the size of the individual again. This means that the population is density dependant with a soft upper border.  

```{r, eval = FALSE}
# This part takes all the available resources, and redistributes them according to 
# host size. It adjusts the resources by relative filtering capacity if the population 
# gets less than maximal food.
Host[Alive.Hosts$Is.Alive, Resource.In := 
       (rpois(
         n = .N, 
         lambda = (Size * min(1, (resources.host[Host.Population[1]] / sum(Size)))) * 
           resource.grain) / resource.grain), 
     by = list(Host.Population, Host.Replicate)]
    
# This part restricts resource in to Size + 10% in order to avoid unrealistic overfeeding
Host[Alive.Hosts$Is.Alive, Resource.In := pmin(Resource.In, (Size * 1.1))]
```

### Infection model
The infection model in the Digital_Coevolution is implemented as a genotype by genotype lookup table that defines the infection affinity between the two genotypes. This can be specified so that the resulting infection model ranges anywhere between a gene-for-gene model to a matching alleles type infection model. Usually the simulation is run as a perfect matching alleles model, with complete parasite specificity.  

```{r, eval = FALSE}
# Infection dynamic parameters, row is host, column is parasite
infection.table <- matrix((1 - parasite.specificity), 
                          nrow = host.genotypes, 
                          ncol = parasite.genotypes)   # row is host, column is parasite

diag(infection.table) <- 1
```

### Host Exposure to Parasites
This is arguably both the most complex and the most important part of the simulation. Here the host agents get exposed to new parasites. The exposure within populations is completely random, i.e. there is no host seeking behavior by the parasite and no parasite avoidance by the host. The simulated transmission should be faeco - oral, so the transmission is linked to the feeding rate. As the parasite population can be both bigger or smaller than the host population, the amount of parasites each host is exposed to varies largely.  
The implementation starts by calculating for each parasite whether or not it has been ingested or not, which is dependent on the size of the host population relative to the available resources (is there over- or underfeeding?). Then each parasite that has been ingested gets assigned the host by which it has been ingested. This is dependent on the size of an individual host relative to the summed-up size of the population. One host individual can ingest several parasites. Not all ingestion events lead to a successful infection. To calculate which parasite succeeded in the infection, there is a random draw from all parasites that infect a host individual, with the probability for each parasite weighted by both the number of spores with that genotype and by the matching of the host genotype and the parasite genotype. Finally, hosts that had already been infected before cannot acquire a new infection (vaccination effect, or simply host being full), but will still eat and remove parasites.  

```{r, eval = FALSE}
# This part sets an identifier to be used later on.
Host[Alive.Hosts$Is.Alive, Host.TempID := 1 : .N]

Host[! Alive.Hosts$Is.Alive, Host.TempID := NA]
  
  set(Parasite, j = "Ingested", value = 0)
  set(Parasite, j = "Attack.Host.TempID", value = NA)
  set(Parasite, j = "Attack.Host.Genotype", value = NA)
  set(Parasite, j = "Success.Parasite.Infection.Genotype", value = NA)
    
# This part removes the identifier from those hosts that already are infected, creating a 
# vaccination effect. 
Host[Alive.Hosts$Is.Alive & Infection.State == 1, Host.TempID := NA]
    
# This part does assign to each parasite score if it has been ingested by a host, 
# dependant on resource availability, host and parasite population size.
Parasite[Alive.Parasites$Is.Alive, 
           Ingested := 
           rbinom(n = .N, 
                  size = 1, 
                  prob = min(1, 
                             (sum(
                               Host[Alive.Hosts$Is.Alive & 
                                      Host.Population == Parasite.Population[1] & 
                                      Host.Replicate == Parasite.Replicate[1], Size]) / 
                                resources.host[Parasite.Population[1]]))), 
         by = list(Parasite.Population, Parasite.Replicate)]
    
# Updating the Alive.Parasites$Is.Ingested vector for faster lookups.
Alive.Parasites[Alive.Parasites$Is.Alive, 
                Is.Ingested := Parasite[Alive.Parasites$Is.Alive, Ingested == 1]]
    
# This part does assign to each parasite spore the host tempID it has been ingested by
Parasite[Alive.Parasites$Is.Ingested,
         Attack.Host.TempID := 
           base:::sample(x = Host[Alive.Hosts$Is.Alive & 
                                    Host.Population == Parasite.Population[1] & 
                                    Host.Replicate == Parasite.Replicate[1], 
                                  Host.TempID], 
                         size = .N, 
                         replace = TRUE, 
                         prob = c(
                           Host[Alive.Hosts$Is.Alive & 
                                  Host.Population == Parasite.Population[1] & 
                                  Host.Replicate == Parasite.Replicate[1], Size] * 
                             (.N / resources.host[Parasite.Population[1]]) * 
                             min(1, resources.host[Parasite.Population[1]] / 
                                   sum(
                                     Host[Alive.Hosts$Is.Alive & 
                                            Host.Population == Parasite.Population[1] & 
                                            Host.Replicate == Parasite.Replicate[1], 
                                          Size]))
                           )
                         ), 
         by = list(Parasite.Population, Parasite.Replicate)]
    
# This part assigns to each parasite the host genotype it has been ingested by.
Parasite[Alive.Parasites$Is.Ingested, Attack.Host.Genotype := 
           Host[Alive.Hosts$Is.Alive][Attack.Host.TempID, Immune.Genotype]]

# This part calculated which parasite successfully infects, takes into account the 
# relative abundance of ingested parasite spores and their genetic specificity.
Parasite[Alive.Parasites$Is.Ingested & ! is.na(Attack.Host.TempID), 
         Success.Parasite.Infection.Genotype := 
           sample(c(NA, Parasite.Infection.Genotype), 
                  size = 1, 
                  prob = c(1, 
                           infection.table[Attack.Host.Genotype[1], 
                                           Parasite.Infection.Genotype]), 
                  replace = TRUE), 
         by = list(Attack.Host.TempID, Parasite.Population, Parasite.Replicate)]

# And the last thing to do would be to assign the infection genotype back to the host.
infected.hosts <- unique(Parasite[Alive.Parasites$Is.Ingested & 
                                    ! is.na(Success.Parasite.Infection.Genotype)], 
                         by = "Attack.Host.TempID")$Attack.Host.TempID

infected.hosts.infection.genotypes <- 
  unique(Parasite[Alive.Parasites$Is.Ingested & 
                    ! is.na(Success.Parasite.Infection.Genotype)], 
         by = "Attack.Host.TempID")$Success.Parasite.Infection.Genotype

Host[Host[, .I[Alive.Hosts$Is.Alive]][infected.hosts], 
     Host.Infection.Genotype := infected.hosts.infection.genotypes]
    
# And the very last thing is to update the infection status of the host that got assigned 
# a infection.genotype.
Host[Alive.Hosts$Is.Alive & ! is.na(Host.Infection.Genotype) & Infection.State == 0, 
     c("Infection.Size", "Infection.State") := 1]
    
# And kill the parasites that have been ingested
Parasite[Alive.Parasites$Is.Ingested, Alive := 0]
```

### Host Resources Simulation Wide
Resources control the size of a simulated population. So the resources can be used together with the migration pattern to create any type of metapopulation. The resources simply control the size of the subpopulations, while the migration pattern controls, well, the migration between the subpopulations. The resources that are available per population are set together with all other variables at the beginning of the simulation. They are implemented as a small integer vector, where the number of vector elements is the number of populations that are going to be simulated, and the value of the vector elements is the size of the simulated population. This way it is possible to simulate a metapopulation that consists of subpopulations of vastly different population sizes.  

```{r, eval = FALSE}
# Here at the same time the number of populations and their size are set. For each 
# population define explicitly the amount of resources it receives daily. Currently, 
# population size settles at about half the resources given. 
resources.host <- c(500, 50, 50)

###
number.populations.host <- length(resources.host)

populations.host <- c(1 : number.populations.host)

starting.population.sizes.host <- ceiling(resources.host / 2)

###
number.populations.parasite< - number.populations.host

populations.parasite <- c(1 : number.populations.parasite)

starting.population.sizes.parasite <- ceiling(resources.host * 10)
```

\newpage
## Between Population Dynamics
A very central feature of the Digtial_Coevolution simulation is that it can simulate several interconnected populations of both host and parasite agents. When we imaginge a host agent population as a glas jar full of zooplankton, then we can imagine the metapopulation as the climate chamber in which the glass jars are standing. Depending on the migration schedule, host or parasite individuals can be moved between different glass jars in the climate chamber. So host and parasite agents can migrate between differnt host and parasite agent populations. Much as would be done in an experiment in a climate chamber, this migration happens once a timestep (once a day). And much as in an experiment, migration can happen at different rates between different populations. Last but not least, those populations can also be of different sizes, with differnt amounts of food available to them.  

### Hierarchical Metapopulation
Population interconnectivity is implemented as a population by population fully crossed lookup table that defines how many individuals move from which population to which, both for the host and the parasite. This allows for the implementation of any arbitrary metapopulation structure, from only lightly diverged large metapopulations to a network of highly diverged populations. Combined with the explicit resource availability per population, this can also create asymmetrical metapopulations, as for example a mainland-island model.  
Most importantly, by enabling the user to specify the metapopulation structure for both the host and the parasite separately, situation can be created where either the host or the parasite migrate substantially more or have a different metapopulation structure, which are research questions of unrivalled interest.  

```{r, eval = FALSE}
# Migration matrix for the host
migration.matrix.host <- matrix((host.migration / number.populations.host), 
                                nrow = number.populations.host, 
                                ncol = number.populations.host)

diag(migration.matrix.host) <- 
  diag(migration.matrix.host) + (1 - host.migration)
  
# Migration matrix for the parasite
migration.matrix.parasite <- matrix((parasite.migration / number.populations.parasite), 
                                    nrow = number.populations.parasite, 
                                    ncol = number.populations.parasite)

diag(migration.matrix.parasite) <- 
  diag(migration.matrix.parasite) + (1 - parasite.migration)
```

### Parasite Migration
This allows the parasite to migrate between different populations. It does so simply by picking a random subset of the free parasite population, and randomly assigning it to a new population. Migration is thus completely random and independent of any parasite properties.  

```{r, eval = FALSE}
parasite.migration.function <- function(){
  Parasite[Alive.Parasites$Is.Alive,
           Parasite.Population := 
             base:::sample(1 : number.populations.parasite, 
                                                size = .N, 
                                                prob = 
                             migration.matrix.parasite[Parasite.Population[1], ], 
                           replace = TRUE), 
           by = list(Parasite.Population, Parasite.Replicate)]
  }
```

### Host Migration
The host migration works analog to the parasite migration. A set fraction of the host population gets chosen at random, and then randomly assigned to a new population.  

```{r, eval = FALSE}
host.migration.function <- function(){
  Host[Alive.Hosts$Is.Alive,
       Host.Population := 
         base:::sample(1 : number.populations.host, 
                       size = .N, 
                       prob = migration.matrix.host[Host.Population[1], ], 
                       replace = TRUE), 
       by = list(Host.Population, Host.Replicate)]
  } 
```

---------------------------------------------------------------------------------------------------

\newpage

# Part Two: Implementation of the Digital_Coevolution simulation

## General description
The Digital_Coevolution simulation has two logical areas. The most important part of the simulation describes all the rules for the behaviour of the individuals, both within individual and between individuals. This "biological logic" is mostly implemented in the functions and parameters that have been described in part one of this document. The second area of the simulation is the implementation of the simulation itself. How an individual actually is simulated, how time is implemented, how results are recorded and so on. 

## Setting up the Digital_Coevolution
### Data structure, or what is an "agent"?
The Digital_Dapnia is implemented in a way that each host or parasite agent is represented as a vector. Each element of the vector corresponds to a certain trait of that agent, as for example age or genotype. Those vectors are then stacked to make up the population, like rows in a table. While a row represents a individual agent with all its traits, reading out a column of this table, perpendicular to the individuals row, gives a vector that represents the variable / trait state of the whole population at a certain timepoint. This allows for the manipulation of all individuals simultaneously if necessary. As agents can reproduce and also die, the population sizes will vary throughout the simulation. This means that the number of rows in the data.table will have to vary throughout the simulation. Having to vary row numbers of data.tables (or worse, data.frames) in a loop is a surefire way to create a really slow simulation. That is why the data.table used is created to be able to accomodate the largest immaginable population size possible in the simulation. Adding a variable / trait that records whether or not the agent that is residing in this row is currently alive or dead allows to subset this larger data.table to just the alive population. This circumvents the growing data.table problem. Digital_Coevolution relies heavily on the data.table package and hence its syntax. The data.table syntax is analoguous to SQL and has three elements: Where, order by / select, and update group / by. View below for the first ten rows of the host data.table at the initializing state of the simulation.  

```{r, echo = FALSE}
library(data.table)
###########################################################
## In the lines below you can adjust some of the parameter 
## settings that influence the simulation

## Beware that combinations of large populations and 
## many replicates might overpower your computer.

# For how many time steps should the simulation run?
# It can help to think of that as days in the life 
# of a digital individual
duration.days <- 1000

# Here you can set how often a snapshot of all individuals 
# should be saved. Every N timesteps
saving.intervall <- 1

# How many replicates should there be?
replicates <- 1

###########################################################
## Here you can adjust the parameters that influence the 
## digital organisms themselves

# How many host populations should there be, and how large
# should they be? This doesn't directly set the number
# of individuals, but the resources that are available 
# per population. More resources will lead to larger 
# populations, but the exact number of individuals 
# that will result depends on many things.
host.populations <- c(100,100) 

# How many host genotypes should there be?
# Note that as default, each host genotype gets its own
# parasite genotype as well. 
host.genotypes <- 5

# Which proportion of the host populations should 
# randomly migrate each time step
host.migration <- 0

# Which proportion of the parasite populations
# should randomly migrate?
parasite.migration <- 0.5

# How genotype specific should the infection
# be in percent?
parasite.specificity <- 1

# How virulent should the parasites be?
# Virulence is implemented as percent resources withdrawn
# per time step, depending on infection size.
virulence <- 0.2 

# How much random drift should there be?
# Defined as proportion per timestep.
# This proportion of the host and the parasite population
# will additionally randomly be killed each timestep.
# A value of zero adds no additional random drift.
random.drift <- 0

# Read in the date, so that stuff can run over night without causing trouble
run.date <- Sys.Date()

######################################################################
######################################################################
###### Parameter space
# Internal dynamic parameters
# Host internal dynamic parameters
host.size <- "OFF" 
age.threshold.host <- 30
resource.threshold.host <- 0.2
reproduction.threshold.host <- 2 
reproduction.factor.host <- 4 
reproduction.allocation <- 0.35
immune.allocation <- 0.35

# Parasite internal dynamic parameters
parasite.genotypes <- host.genotypes
age.threshold.parasite <- 60 
reproduction.threshold.parasite <- 2 
reproduction.factor.parasite <- 23 

# Infection dynamic parameters, row is host, column is parasite
infection.table <- matrix((1 - parasite.specificity), 
                          nrow = host.genotypes, 
                          ncol = parasite.genotypes) 
diag(infection.table) <- 1

# This factor gives the per time unit growth of a infection, in percent
infection.growth.factor <- 1.15 

# Resource parameters
# This is the modifier that can increase or decrease the variance in resource 
# distribution. The higher the number the less variance. With value 1 its a normal 
# poisson distribution.
resource.grain <- 10 

######################################################################
######################################################################
# Here at the same time the number of populations and their size are set. For each 
# population define explicitly the amount of resources it receives daily. Currently, 
# population size settles at about half the resources given.
resources.host <- host.populations

###
number.populations.host <- length(resources.host)
populations.host <- c(1 : number.populations.host)
starting.population.sizes.host <- ceiling(resources.host / 2)

###
number.populations.parasite <- number.populations.host
populations.parasite <- c(1 : number.populations.parasite)
starting.population.sizes.parasite <- ceiling(resources.host * 10)

###
# External Population dynamic parameters:
migration.matrix.host <- matrix((host.migration / number.populations.host), 
                                nrow = number.populations.host, 
                                ncol = number.populations.host)

diag(migration.matrix.host) <- 
  diag(migration.matrix.host) + (1 - host.migration)

migration.matrix.parasite <- matrix((parasite.migration / number.populations.parasite), 
                                    nrow = number.populations.parasite, 
                                    ncol = number.populations.parasite)

diag(migration.matrix.parasite) <- 
  diag(migration.matrix.parasite) + (1 - parasite.migration)
 
######################################################################
######################################################################
# In this step I preallocate all the data.table space that I could be using in an 
# attempt to speed up the simulation.
individual.creator.function <- function(){
  
  preallocation.margin <- 10 # How many times larger the data.table size.
  
  parasite.margin <- 1
  
  preallocation.length <- 
    sum(starting.population.sizes.host * replicates * preallocation.margin)
  
  preallocation.parasite <- 
    sum(starting.population.sizes.parasite * replicates * 
          preallocation.margin * parasite.margin)

  
  if(exists("Host")) {rm(Host, pos = ".GlobalEnv")}

    
  Host <<- data.table(  
    Alive = integer(preallocation.length),
    Host.Replicate = integer(preallocation.length), 
    Time = integer(preallocation.length),
    Host.Population = integer(preallocation.length),
    Host.Infection.Genotype = factor(NA, levels = c(1 : parasite.genotypes)),
    Age = integer(preallocation.length),
    Resource.Have = numeric(preallocation.length),
    Reproduction.Allocation = numeric(preallocation.length),
    Immune.Allocation = numeric(preallocation.length),
    Immune.Genotype = factor(sample(c(1 : host.genotypes), 
                                    size = preallocation.length, 
                                    prob = rep(1 / host.genotypes,host.genotypes), 
                                    replace = T), 
                             levels = c(1 : host.genotypes)),
    Resource.In = numeric(preallocation.length),
    Resource.Work = numeric(preallocation.length),
    Reproduction.Have = numeric(preallocation.length),
    Immune.State = numeric(preallocation.length),
    Infection.State = integer(preallocation.length),
    Infection.Size = numeric(preallocation.length),
    Parasite.Resources = numeric(preallocation.length),
    Host.TempID = integer(preallocation.length),
    Size = numeric(preallocation.length),
    Host.Generation = integer(preallocation.length),
    Origin = integer(preallocation.length)
  )

  # Here I initialize the starter populations.
  # Replicate, this way I hope to paralellize the replicate calculations.
  Host[, Host.Replicate := 
         c(rep(1 : replicates, 
               each = sum(starting.population.sizes.host)), 
           integer(preallocation.length - sum(starting.population.sizes.host) * 
                     replicates))]
  
  # Alive variable, 1 = alive, 0 = not alive
  Host[Host.Replicate != 0, Alive := 1L] 
  
  # Population
  Host[Alive == 1, Host.Population := 
         as.integer(rep(1 : number.populations.host, 
                        times = starting.population.sizes.host)), 
       by = Host.Replicate]
  
  # Age
  Host[Alive == 1, Age := 1L]
    
  # Resource.Have
  Host[Alive == 1, Resource.Have := 1]
    
  # Resource.In, meaning that the starters start with a full belly
  Host[Alive == 1, Resource.In := 1]
    
  # Reproduction.Allocation
  Host[Alive == 1, Reproduction.Allocation := reproduction.allocation]
    
  # Immune.Allocation
  Host[Alive == 1, Immune.Allocation := immune.allocation]  
    
  # Immune.Genotype, has been set when initializing, needs to be cleaned
  Host[Alive == !1, Immune.Genotype := NA] 
    
  # Infection.Genote
  Host[, Host.Infection.Genotype := NA]
    
  # Size
  Host[Alive == 1, Size := 1]
    
  # Host.Generation
  Host[Alive == 1, Host.Generation := 1L]
    
  # Origin
    Host[Alive == 1, Origin := Host.Population]

  ### 
  # Here I start a vector that just contains if a host is alive or not, to circumvent all 
  # the lookups.
  if(exists("Alive.Host")) {rm(Alive.Host, pos = ".GlobalEnv")}
    
  Alive.Hosts <<- data.table(Is.Alive = Host[, Alive == 1])
    
  # Here I initialize the parasite data.table structure
  if(exists("Parasite")) {rm(Parasite, pos = ".GlobalEnv")}
  
  
  Parasite <<- data.table(
    Alive = integer(preallocation.parasite),
    Parasite.Replicate = integer(preallocation.parasite), 
    Time = integer(preallocation.parasite),
    Parasite.Population = integer(preallocation.parasite),
    
    Parasite.Infection.Genotype = 
      factor(sample(c(1 : parasite.genotypes),
                    size = preallocation.parasite, 
                    prob = rep(1 / parasite.genotypes, parasite.genotypes), replace = T), 
             levels = c(1 : parasite.genotypes)),
    
    Attack.Host.TempID = integer(preallocation.parasite),
    Attack.Host.Genotype = factor(sample(c(1 : parasite.genotypes),
                    size = preallocation.parasite, 
                    prob = rep(1 / parasite.genotypes, parasite.genotypes), replace = T), 
             levels = c(1 : parasite.genotypes)),
    Success.Parasite.Infection.Genotype = factor(NA, levels = c(1 : parasite.genotypes)),
    Ingested = integer(preallocation.parasite),
    Age = integer(preallocation.parasite)
  )
  

  # Here I initialize the starter populations for the parasite Replicate
  Parasite[, Parasite.Replicate := 
             c(rep(1 : replicates, each = sum(starting.population.sizes.parasite)),
               integer(preallocation.parasite - 
                         sum(starting.population.sizes.parasite) * replicates))]
  
  # Alive variable, 1 = alive, 0 = not alive
  Parasite[Parasite.Replicate != 0, Alive := 1L]
  
  # Population
  Parasite[Alive == 1, 
           Parasite.Population := 
             as.integer(rep(1 : number.populations.parasite, 
                            times = starting.population.sizes.parasite)), 
           by = Parasite.Replicate]
  
  # Age 
  Parasite[Alive == 1, Age := 1L]
  
  # Infection.Genotype, has been set when initializing, needs to be cleaned
  Parasite[Alive != 1, Parasite.Infection.Genotype := NA]
  
  # Atack.Host.Rownumber
  Parasite[, Attack.Host.TempID := NA]
  
  # Atack.Host.Genotype
  Parasite[, Attack.Host.Genotype := NA]
  
  # Here I start a vector that just contains if a Parasite is alive or not, to circumvent 
  # all the lookups
  if(exists("Alive.Parasite")) {rm(Alive.Parasite, pos = ".GlobalEnv")}
  
  Alive.Parasites <<- data.table(Is.Alive = Parasite[, Alive == 1], Is.Ingested = FALSE)

# Close the individual.creator.function.  
}

# Just run the individual.creator.function once
individual.creator.function()

# Here I just have a look at the host and parasite data.table
head(Host, 10)
```

### The creation of the first individuals
One of the first things the simulation has to do is to create the host and parasite individuals. Otherwise the simulation has nothing to calculate on. The individuals are created by a call to the individual.creator.function that is defined in the "Digital_Coevolution_Dynamics_Functions" script. It uses variables that are set in either the "Digital_Coevolution_User" script and the "Digital_Coevolution_Parameterspace" script. That includes variables that will regularly be changed like the number of replicates, and variables that will be changed less often, like the allocation of resources to reproduction.
The individual.creator.function creates two data.tables, one for the host, one for the parasite, where each line corresponds to one individual.  

```{r, eval = FALSE}
######################################################################
# In this step I preallocate all the data.table space that I could be using in an 
# attempt to speed up the simulation.
individual.creator.function <- function(){
  
  preallocation.margin <- 10 # How many times larger the data.table size.
  
  parasite.margin <- 1
  
  preallocation.length <- 
    sum(starting.population.sizes.host * replicates * preallocation.margin)
  
  preallocation.parasite <- 
    sum(starting.population.sizes.parasite * replicates * 
          preallocation.margin * parasite.margin)

  
  if(exists("Host")) {rm(Host, pos = ".GlobalEnv")}

    
  Host <<- data.table(  
    Alive = integer(preallocation.length),
    Host.Replicate = integer(preallocation.length), 
    Time = integer(preallocation.length),
    Host.Population = integer(preallocation.length),
    Host.Infection.Genotype = factor(NA, levels = c(1 : parasite.genotypes)),
    Age = integer(preallocation.length),
    Resource.Have = numeric(preallocation.length),
    Reproduction.Allocation = numeric(preallocation.length),
    Immune.Allocation = numeric(preallocation.length),
    Immune.Genotype = factor(sample(c(1 : host.genotypes), 
                                    size = preallocation.length, 
                                    prob = rep(1 / host.genotypes,host.genotypes), 
                                    replace = T), 
                             levels = c(1 : host.genotypes)),
    Resource.In = numeric(preallocation.length),
    Resource.Work = numeric(preallocation.length),
    Reproduction.Have = numeric(preallocation.length),
    Immune.State = numeric(preallocation.length),
    Infection.State = integer(preallocation.length),
    Infection.Size = numeric(preallocation.length),
    Parasite.Resources = numeric(preallocation.length),
    Host.TempID = integer(preallocation.length),
    Size = numeric(preallocation.length),
    Host.Generation = integer(preallocation.length),
    Origin = integer(preallocation.length)
  )

  # Here I initialize the starter populations.
  # Replicate, this way I hope to paralellize the replicate calculations.
  Host[, Host.Replicate := 
         c(rep(1 : replicates, 
               each = sum(starting.population.sizes.host)), 
           integer(preallocation.length - sum(starting.population.sizes.host) * 
                     replicates))]
  
  # Alive variable, 1 = alive, 0 = not alive
  Host[Host.Replicate != 0, Alive := 1L] 
  
  # Population
  Host[Alive == 1, Host.Population := 
         as.integer(rep(1 : number.populations.host, 
                        times = starting.population.sizes.host)), 
       by = Host.Replicate]
  
  # Age
  Host[Alive == 1, Age := 1L]
    
  # Resource.Have
  Host[Alive == 1, Resource.Have := 1]
    
  # Resource.In, meaning that the starters start with a full belly
  Host[Alive == 1, Resource.In := 1]
    
  # Reproduction.Allocation
  Host[Alive == 1, Reproduction.Allocation := reproduction.allocation]
    
  # Immune.Allocation
  Host[Alive == 1, Immune.Allocation := immune.allocation]  
    
  # Immune.Genotype, has been set when initializing, needs to be cleaned
  Host[Alive == !1, Immune.Genotype := NA] 
    
  # Infection.Genote
  Host[, Host.Infection.Genotype := NA]
    
  # Size
  Host[Alive == 1, Size := 1]
    
  # Host.Generation
  Host[Alive == 1, Host.Generation := 1L]
    
  # Origin
    Host[Alive == 1, Origin := Host.Population]

  ### 
  # Here I start a vector that just contains if a host is alive or not, to circumvent all 
  # the lookups.
  if(exists("Alive.Host")) {rm(Alive.Host, pos = ".GlobalEnv")}
    
  Alive.Hosts <<- data.table(Is.Alive = Host[, Alive == 1])
    
  # Here I initialize the parasite data.table structure
  if(exists("Parasite")) {rm(Parasite, pos = ".GlobalEnv")}
  
  
  Parasite <<- data.table(
    Alive = integer(preallocation.parasite),
    Parasite.Replicate = integer(preallocation.parasite), 
    Time = integer(preallocation.parasite),
    Parasite.Population = integer(preallocation.parasite),
    
    Parasite.Infection.Genotype = 
      factor(sample(c(1 : parasite.genotypes),
                    size = preallocation.parasite, 
                    prob = rep(1 / parasite.genotypes, parasite.genotypes), replace = T), 
             levels = c(1 : parasite.genotypes)),
    
    Attack.Host.TempID = integer(preallocation.parasite),
    Attack.Host.Genotype = factor(sample(c(1 : parasite.genotypes),
                    size = preallocation.parasite, 
                    prob = rep(1 / parasite.genotypes, parasite.genotypes), replace = T), 
             levels = c(1 : parasite.genotypes)),
    Success.Parasite.Infection.Genotype = factor(NA, levels = c(1 : parasite.genotypes)),
    Ingested = integer(preallocation.parasite),
    Age = integer(preallocation.parasite)
  )
  

  # Here I initialize the starter populations for the parasite Replicate
  Parasite[, Parasite.Replicate := 
             c(rep(1 : replicates, each = sum(starting.population.sizes.parasite)),
               integer(preallocation.parasite - 
                         sum(starting.population.sizes.parasite) * replicates))]
  
  # Alive variable, 1 = alive, 0 = not alive
  Parasite[Parasite.Replicate != 0, Alive := 1L]
  
  # Population
  Parasite[Alive == 1, 
           Parasite.Population := 
             as.integer(rep(1 : number.populations.parasite, 
                            times = starting.population.sizes.parasite)), 
           by = Parasite.Replicate]
  
  # Age 
  Parasite[Alive == 1, Age := 1L]
  
  # Infection.Genotype, has been set when initializing, needs to be cleaned
  Parasite[Alive != 1, Parasite.Infection.Genotype := NA]
  
  # Atack.Host.Rownumber
  Parasite[, Attack.Host.TempID := NA]
  
  # Atack.Host.Genotype
  Parasite[, Attack.Host.Genotype := NA]
  
  # Here I start a vector that just contains if a Parasite is alive or not, to circumvent 
  # all the lookups
  if(exists("Alive.Parasite")) {rm(Alive.Parasite, pos = ".GlobalEnv")}
  
  Alive.Parasites <<- data.table(Is.Alive = Parasite[, Alive == 1], Is.Ingested = FALSE)

# Close the individual.creator.function.  
}
```

### Dead or alive?
The agents of the Digital_Coevolution simulation can be, much like biological individuals, either dead or alive. In order to speed up the simulation as much as possible, calculations should only be done with the alive subset of a population. This is possible by using the "Alive" variable, which can take the values 0 = dead and 1 = alive. As a subsetting operation always is a comparison operation between the queried value and all values in the vector that is to be subsetted, it can become slow. The data.table package already has internal optimisation to make this type of lookup as fast as possible, yet there are still some gains in speed to be had when the comparison operation is circumvented completely. This is especially valuable when a comparison is done repeatedly. To check wether or not an individual agent is still alive is one such operation which can be optimized. In the Digital_Coevolution this is done by creating an external vector (or to be more precise, a one-column data.table) that has the same lenght as the number of rows of the data.table that contains the agents. This external vector contains the information which agent is currently alive in logical form, alive = TRUE. It is essentially a copy of the trait "Alive" in logical form. This vector can now be used to subset the data.table that contains the agents to only the agents which are alive, without the necessity for a comparison operation. It does need to be carefully updated whenever a agent dies or gets born. The possible speed gains are worth it though.  
For the host agents, the "Alive.Hosts" vector is created like this:  

```{r, eval = FALSE}
# Here I start a vector that just contains if a host is alive or not, to circumvent all 
# the lookups.
Alive.Hosts <<- data.table(Is.Alive = Host[, Alive == 1])
```

And everytime the aliveness status of an agent changes, it is updated like this:  

```{r, eval = FALSE}
set(Alive.Hosts, j = "Is.Alive", value = Host[, Alive == 1])
```

And it is used like this:  

```{r, eval = FALSE}
# Host migration function.
host.migration.function <- function(){
  Host[Alive.Hosts$Is.Alive,
       Host.Population := 
         base:::sample(1 : number.populations.host, 
                       size = .N, 
                       prob = migration.matrix.host[Host.Population[1], ], 
                       replace = TRUE), 
       by = list(Host.Population, Host.Replicate)]
  } 
```

### Setting global values
There are a few things that do not change during the running of the Digital_Coevolution Simulation. The number of genotypes that are simulated for example, or the resources that each population gets per timestep. Those variables or parameters have to be set before the actual simulation process starts, so that the simulation process can use them.  
Those variables are mostly set in one of two places. The first place to define variables, and the one most users will interact with, is the  "Digital_Coevolution_User" script. There one can set variables like the number of genotypes or the amount of resources per population, which are likely to be varied between runs of the simulation. The variables set in the user script mostly dont interfere with the behaviour of the agents themselves, but are "population wide" variables like migration rates. The other place where variables are set is the "Digital_Coevolution_Parameterspace" script. In that script more stable variables are defined that can interfere with the behaviour of the individuals and should be handeled carefully. Here one would for example set the resource conversion rate for the parasite, or the old age threshhold for host individuals. Changing the variables in the "Digital_Coevolution_Parameterspace" script alters the nature of the individuals that are simulated. It can be used to change the type of organism that one is trying to simulate. One can try to parametrize the simulation to behave more like an k-strategist instead of an r-strategist for example.  

```{r, eval = FALSE}
###### Parameter space
# Internal dynamic parameters
# Host internal dynamic parameters
host.size <- "OFF" 
age.threshold.host <- 30
resource.threshold.host <- 0.2
reproduction.threshold.host <- 2 
reproduction.factor.host <- 4 
reproduction.allocation <- 0.35
immune.allocation <- 0.35

# Parasite internal dynamic parameters
parasite.genotypes <- host.genotypes
age.threshold.parasite <- 60 
reproduction.threshold.parasite <- 2 
reproduction.factor.parasite <- 23 

# Infection dynamic parameters, row is host, column is parasite
infection.table <- matrix((1 - parasite.specificity), 
                          nrow = host.genotypes, 
                          ncol = parasite.genotypes) 
diag(infection.table) <- 1

# This factor gives the per time unit growth of a infection, in percent
infection.growth.factor <- 1.15 

# Resource parameters
# This is the modifier that can increase or decrease the variance in resource 
# distribution. The higher the number the less variance. With value 1 its a normal 
# poisson distribution.
resource.grain <- 10 

######################################################################
######################################################################
# Here at the same time the number of populations and their size are set. For each 
# population define explicitly the amount of resources it receives daily. Currently, 
# population size settles at about half the resources given.
resources.host <- host.populations

###
number.populations.host <- length(resources.host)
populations.host <- c(1 : number.populations.host)
starting.population.sizes.host <- ceiling(resources.host / 2)

###
number.populations.parasite <- number.populations.host
populations.parasite <- c(1 : number.populations.parasite)
starting.population.sizes.parasite <- ceiling(resources.host * 10)

###
# External Population dynamic parameters:
migration.matrix.host <- matrix((host.migration / number.populations.host), 
                                nrow = number.populations.host, 
                                ncol = number.populations.host)

diag(migration.matrix.host) <- 
  diag(migration.matrix.host) + (1 - host.migration)

migration.matrix.parasite <- matrix((parasite.migration / number.populations.parasite), 
                                    nrow = number.populations.parasite, 
                                    ncol = number.populations.parasite)

diag(migration.matrix.parasite) <- 
  diag(migration.matrix.parasite) + (1 - parasite.migration)

```

\newpage
## The simulation process

### The dynamics wrapper
We are approaching the heart of the Digital_Coevolution simulation. All of the biological logic that was explained in part one of this document results in functions. Functions in R are collections of code that are defined under a common name and will be executed once the function is called. In the Digital_Coevolution simulation, each of the distinct within agent and between agent dynamics that were explained in part one is defined as a sepparate function. The migration function of the host for example is designed like this:  

```{r, eval = FALSE}
# Host migration function.
host.migration.function <- function(){
  Host[Alive.Hosts$Is.Alive, 
       Host.Population := 
         base:::sample(1 : number.populations.host, 
                       size = .N, 
                       prob = migration.matrix.host[Host.Population[1], ], 
                       replace = TRUE), 
       by = list(Host.Population, Host.Replicate)]
} 
```

Having all the different rules for dynamic behaviour of the agents defined as sepparate functions does allow us to invoke them sepparately. That is important, as they will be executed consecutively in the simulation. The order in which the functions are called can have a big influence on the biological logic behind the Digital_Coevolution. The timing of migration for example is important. Does migration of parasite agents happen after the parasite reproduces but before there is a new round of hosts being exposed to parasites? Or will the parasites migrate after an exposure event? This simple question of timing will influence whether coevolution has a more local component or a more global component.  
Nevertheless, every timestep all of the functions that govern the agents will have to be called once for a full agent life cycle. To achieve that, and to ensure consistent order in the calling of functions, they will be wrapped in another function that is called "dynamics.wrapper" in the simulation. All this dynamics wrapper does is simply calling the functions that define the agents behaviour one after another. One call of the dynamics.wrapper function is one time-step in the simulation.  

```{r, eval = FALSE}
# Here I will combine all the functions defined above into one wrapper function to be 
# called. One call is one timestep. The order of the function can have an influence on 
# the dynamics of the thing.
dynamics.wrapper <- function(){
  time.function()
  senescence.function()
  host.resource.function()
  infection.function()
  host.exposure.function()
  parasite.reproduction.function()
  metabolism.function()
  host.reproduction.function()
  host.migration.function()
  parasite.migration.function()
}
```

### Getting Results
Just running the Digital_Coevolution simulation through time-steps is nice and dandy, but somehow we have to get at what is happening to the host agents and parasite agents during this simulation. In order to do that there is a piece of code in the Digital_Coevolution_Run.R script that will save a copy the complete host agent and parasite agent population to a file on the disc. This means we get a complete snapshot of every single agent, all its internal states like reproduction, infection, resources and so on whenever we wish. Long simulations with large populations will create big data files, so keep that in mind when using Digital_Coevolution. This data extracting process is implemented using the fwrite function from the data.table package in append mode. This means that whenever it is invoked, it will take both the host and parasite agent population data.tables and save it to disk. Instead of creating a new file for every time a copy is saved, the append mode uses the same data file everytime, and simply adds the new data at the bottom of it. This is where all the identifiers for time and replicate come in handy, as it allow us to filter the resulting dataset very precisely. The "by = " argument in the "if" statement that wraps the fwrite adjusts the resolution of the data saving. A value of 1 will save the state of all agents every timestep. A value of ten will save the state of all agents only every tenth timestep. This can be used to greatly reduce the size of the resulting data file for simulation runs over many timesteps. It can also be used to speed up the simulation, as writing to disk can take a lot of time. The fwrite function is already optimized to be fast, but if an older system with a harddrive instead of a solid state drive is used can nevertheless use up quite some time. For long simulations, it is worth it to consider if it is necessary to save every timestep, or if less data is sufficient as well.  
There is also a toggle that allows you to get a summarized report instead of a raw copy of the host and parasite agent states (see part three, section "running the Digital_Coevolution simulation on your local machine"). If that toggle is enabled, then instead of a raw copy, a summary report will be created at each reporting time step. That summary includes the number of host or parasite individuals per genotype per sub- or metapopulation and the number of infections. It lacks some of the details of the raw data, but is a much more handeable dataset. 

```{r, eval = FALSE}
# Because it is a time forward simulation it is necessary to loop through the timesteps. 
# We do that by calling the dynamics.wrapper function within a loop. 
# The dynamics.wrapper contains all the functions that guide the dynamics of the 
# individuals in each timestep (as for example the host.reproduction.function).
for(i in 1 : duration.days){
  dynamics.wrapper()
  # result saving
  if(i %in% 
     c(1, seq(from = saving.intervall, to = duration.days, by = saving.intervall))){
    if(raw.results){
      fwrite(Host[Alive.Hosts$Is.Alive], file = 
               paste(result.file.location, 
                     result.file.name, 
                     "_Host_", 
                     run.date, 
                     "_raw_", 
                     ".csv", 
                     sep = ""), append = TRUE)
      fwrite(Parasite[Alive.Parasites$Is.Alive], file = 
               paste(result.file.location, 
                     result.file.name, 
                     "_Parasite_", 
                     run.date, 
                     "_raw_", 
                     ".csv", 
                     sep = ""), append = TRUE)
    } 
    if(summarized.results) {
      temp.data.host <- copy(Host)
      temp.data.host[, Virulence := virulence]
      temp.data.host[, Popsize := host.populations[1]]
      temp.data.host[, Random.Drift := random.drift]
      temp.data.host[, Parasite.Connection := parasite.migration]
      temp.data.host[, Host.Connection := host.migration]
      temp.data.host[, Host.Time := Time]
  
      temp.data.host[, Host.Number.Individuals := .N, 
                     by = list(Host.Time, Host.Replicate, Host.Population, 
                               Immune.Genotype, Virulence, Popsize, Parasite.Connection,
                               Host.Connection)]
      temp.data.host[, Host.Population.Size := .N, 
                     by = list(Host.Time, Host.Replicate, Host.Population, Virulence, 
                               Popsize, Parasite.Connection, Host.Connection)]
      temp.data.host[, Host.Number.Individuals.Between := .N, 
                     by = list(Host.Time, Host.Replicate, Immune.Genotype, Virulence, 
                               Popsize, Parasite.Connection, Host.Connection)]
      temp.data.host[, Host.Population.Size.Between := .N, 
                     by = list(Host.Time, Host.Replicate, Virulence, Popsize, 
                               Parasite.Connection, Host.Connection)]
      temp.data.host[, Epidemic.Size.Within := sum(Infection.State), 
                     by = list(Host.Time, Host.Replicate, Host.Population, 
                               Immune.Genotype, Virulence, Popsize, Parasite.Connection,
                               Host.Connection)]
      temp.data.host[, Epidemic.Size.Total := sum(Infection.State), 
                     by = list(Host.Time, Host.Replicate, Host.Population, Virulence, 
                               Popsize, Parasite.Connection, Host.Connection)]
      
      #########
      temp.data.parasite <- copy(Parasite)
      temp.data.parasite[, Virulence := virulence]
      temp.data.parasite[, Popsize := host.populations[1]]
      temp.data.parasite[, Random.Drift := random.drift]
      temp.data.parasite[, Parasite.Connection := parasite.migration]
      temp.data.parasite[, Host.Connection := host.migration]
      temp.data.parasite[, Parasite.Time := Time]

      temp.data.parasite[, Parasite.Number.Individuals := .N, 
                         by = list(Parasite.Time, Parasite.Replicate, 
                                   Parasite.Population, Parasite.Infection.Genotype, 
                                   Virulence, Popsize, Parasite.Connection, 
                                   Host.Connection)]
      temp.data.parasite[, Parasite.Population.Size := .N, 
                         by = list(Parasite.Time, Parasite.Replicate, Parasite.Population, 
                                   Virulence, Popsize, Parasite.Connection, 
                                   Host.Connection)]
      temp.data.parasite[, Parasite.Number.Individuals.Between := .N, 
                         by = list(Parasite.Time, Parasite.Replicate, 
                                   Parasite.Infection.Genotype, Virulence, Popsize, 
                                   Parasite.Connection, Host.Connection)]
      temp.data.parasite[, Parasite.Population.Size.Between := .N, 
                         by = list(Parasite.Time, Parasite.Replicate, Virulence, Popsize,
                                   Parasite.Connection, Host.Connection)]
      
      #########
      temp.data.host[, Total.Parasite.Number.Individuals := 
                       Epidemic.Size.Within + 
                       temp.data.parasite[
                         Parasite.Replicate == Host.Replicate[1] & 
                           Parasite.Population == Host.Population[1] & 
                           Parasite.Time == Host.Time[1] & 
                           Parasite.Infection.Genotype == Immune.Genotype[1], .N], 
                     by = list(Host.Time, Host.Replicate, Host.Population, 
                               Immune.Genotype, Virulence, Popsize, Parasite.Connection,
                               Host.Connection)]
      temp.data.host[, Total.Parasite.Population.Size := 
                       Epidemic.Size.Total + 
                       temp.data.parasite[
                         Parasite.Replicate == Host.Replicate[1] & 
                           Parasite.Population == Host.Population[1] & 
                           Parasite.Time == Host.Time[1], .N], 
                     by = list(Host.Time, Host.Replicate, Host.Population, Virulence, 
                               Popsize, Parasite.Connection, Host.Connection)]

      temp.data.host[, Total.Parasite.Number.Individuals.Between := 
                       Epidemic.Size.Within + 
                       temp.data.parasite[
                         Parasite.Replicate == Host.Replicate[1] & 
                           Parasite.Population == Host.Population[1] & 
                           Parasite.Time == Host.Time[1] &  
                           Parasite.Infection.Genotype == Immune.Genotype[1], .N], 
                     by = list(Host.Time, Host.Replicate, Immune.Genotype, Virulence, 
                               Popsize, Parasite.Connection, Host.Connection)]
      temp.data.host[, Total.Parasite.Population.Size.Between := 
                       Epidemic.Size.Total + 
                       temp.data.parasite[
                         Parasite.Replicate == Host.Replicate[1] & 
                           Parasite.Population == Host.Population[1] & 
                           Parasite.Time == Host.Time[1], .N], 
                     by = list(Host.Time, Host.Replicate, Virulence, Popsize, 
                               Parasite.Connection, Host.Connection)]
      
      #########
      fwrite(
        unique(temp.data.host[, 
                              list(Host.Time, Host.Replicate, Host.Population, 
                                   Immune.Genotype, Virulence, Popsize, Random.Drift,
                                   Parasite.Connection, Host.Connection, 
                                   Host.Number.Individuals, Host.Population.Size,
                                   Host.Number.Individuals.Between, 
                                   Host.Population.Size.Between, Epidemic.Size.Within,
                                   Epidemic.Size.Total, Total.Parasite.Number.Individuals,
                                   Total.Parasite.Population.Size,
                                   Total.Parasite.Number.Individuals.Between,
                                   Total.Parasite.Population.Size.Between, Origin)]), 
        file = paste(
          result.file.location, 
          result.file.name, 
          "_Host_", 
          run.date, 
          "_summarized_", 
          ".csv", sep = ""), append = TRUE)

      fwrite(
        unique(temp.data.parasite[, 
                                  list(Parasite.Time, Parasite.Replicate, 
                                       Parasite.Population, Parasite.Infection.Genotype, 
                                       Virulence, Popsize, Random.Drift, 
                                       Parasite.Connection, Host.Connection,
                                       Parasite.Number.Individuals, 
                                       Parasite.Population.Size, 
                                       Parasite.Number.Individuals.Between,
                                       Parasite.Population.Size.Between)]),
        file = paste(
          result.file.location, 
          result.file.name, 
          "_Parasite_", 
          run.date, 
          "_summarized_", 
          ".csv", sep = ""), append = TRUE)
      
    }
  }
}

```

### Time
The simulation is implemented as a time forward simulation, meaning that each timestep is calculated consecutively and dependent on the last timestep. At each timestep in a defined interval the whole population gets copied to a results database. This necessitates a time identifier. It is implemented as a integer counter that updates each timestep.  

```{r, eval = FALSE}
Host[, Time := Time + 1L]
Parasite[, Time := Time + 1L]
```

### Time-forward simulation
The simulation is implemented as a time-forward simulation. This means that the simulation loops through discrete time-steps. Each time-step, all dynamics functions get called and the host and parasite agent data.tables get updated where necessary. Then the next time step is calculated with the updated datasets. This is on one hand necessary technically, as the simulation contains a number of stochastic elements. Together with the context dependency of many of the dynamical functions, closed form solutions are unattainable. On the other hand it also allows for a very fine-grained analysis of temporal dynamics of host and parasite coevolution, as every timestep the status of the simulation can be examined fully. This is especially valuable for systems where at least part of the dynamics has a time-shift property.  
The time-forward property of the Digital_Coevolution is simply implemented as a for-loop. A for loop in R simply calls its arguments for N times consecutively. Thats it. And that is all that it needs to be for the Digital_Coevolution. The number of times over which the R for loop iterates is the number of timesteps that the simulation is run over. This scales roughly linearly, as every time-step the same functions get evaluated.  
This is what runs the Digital_Coevolution simulation.  

```{r, eval = FALSE}
# Now we run the simulation
# Because it is a time forward simulation it is necessary to loop through the timesteps. 
for(i in 1 : duration.days){
  dynamics.wrapper()
}
```

-------------------------------------------------------------------------------------------------

<br>
\newpage

# Part Three: Using the Digital_Coevolution simulation
The Digital_Coevolution simulation currently consits of three to four interdependent R scripts. In oder to be able to run the Digital_Coevolution simulation yourself, you simply have to to download or copy the relevant scripts from the github repository to your computer. The Digital_Coevolution simulation is implemented in R, so you will need a R installation as well. You can download the newest R version for your system from [CRAN.](https://cran.r-project.org/)

## Digital_Coevolution on your local machine
### Getting Digital_Coevolution simulation on your computer
You want to run the Digital_Coevolution on your computer (your local machine). That is very easy. You will have to download (or copy) the R scripts named "Digital_Coevolution_Dynamics_Functions.R", "Digital_Coevolution_Parameterspace.R", "Digital_Coevolution_Run.R" and "Digital_Coevolution_User.R" onto your computer. Put them all in the same folder. You will only have to interact with the "Digital_Coevolution_User.R" file. You can open and have a look at all of them though, there should be some comments that explain which part is doing what. But beware, fiddling around in there can break stuff.  
The Digital_Coevolution simulation has been successfully run on windows, linux and macintosh.  

### Run a single  parameterset on your local machine
Open the "Digital_Coevolution_User.R" file in your favourite editor. There is one thing that has to be done carefully. The first uncommented line, that sets the source.file.location, needs to be adapted. There you have to specify the file path of the folder into which you have downloaded the Digital_Coevolution R scripts. This will allow the R scripts to communicate with each other.  
A bit further down in the script you have to specify the file path where the simulation should save the results. It can be the same folder than the scripts. And even a bit further down you have to name the result file. Make it a rememberable and also meaningfull name, so that later you still know what was done in that simulation.  
You will also find settings called "raw.results" and "summarized.results". There you can adjust if you want the raw results, meaning if a copy of the state of each host and parasite agent that exists in the simulation at the time of the reporting should be saved, or if you want summarized results. The summarized results contains for example number of individuals per genotype, per population, per metapopulation and so on, for both host and parasite agents as well as the infection state. Calculating the summary takes slightly longer, so if you are really hard pressed for time the simulation is faster with "summarized.results" set to FALSE.  

```{r, eval = FALSE}
############################################
### User script for Digital_Coevolution ####
############################################

## This is the script you should be working with when you
## want to use the Digital_Organism.
## There is a few things that have to be done carefully in
## order for this to work smoothly.
## Simply work through this script line by line and 
## follow the instructions.
## Have fun!

###########################################################
## The simulation relies upon four .R files (one of which
## you are reading right now), which you should all have 
## in the same folder.

# Please type the full path to the folder that contains 
# the .R files, including this one.
source.file.location <- "/home/example/path/to/Rscripts/"

###########################################################
## The next thing to do is to define where the script 
## should save its results.
## This can be the same folder as the .R files, or any 
## other folder with writing permission.

# Please type the full path to the folder where results 
# should be saved.
result.file.location <- "/home/example/path/to/results/"

###########################################################
## Now we need a name to identify the results.
## The result file will anyway have the name :
## "Digital_Coevolution_Results_Sys.Date_", 
## your filename will be added at the end of that.
result.file.name <- "YourResultNameHere"

###########################################################
# Here you can set if the results should be saved raw 
# or summarized or both, logical value FALSE or TRUE
raw.results <- FALSE
summarized.results <- TRUE
```

The remainder of the file allows you to set some of the parameters of the simulation. This is where stuff gets interesting, and you should play around with the values. Don't worry, here you should not be able to break the simulation. You can for example set how many host populations should be simulated. And how large they should be. Or how virulent the parasite should be. If you specify too large host populations and a too long "duration.days" at the same time, the simulation will take a very long time and produce a very large result data set. How long a run of the simulation actually takes is anyones guess, as that depends heavily on the abilities of your local machine. Best would be to start small and work your way up.  
One important setting that can help you to reduce the result file size for long simulation is the saving.interval. This simply means that every N time steps the complete host and parasite data.tables will be saved into the data file in append mode. If the setting is left at 1, the default, then every time step will be saved. If you set another value, lets say 10, then only every 10 timesteps will be saved, thus decreasing the size of the final output file by 10, but also decreasing your resolution in time. The simulation will run slightly faster if the reporting window is larger. If the reporting window is set to the same value as the duration of the simulation in "duration.days", then only the starting and the ending state of the simulation will be saved. As with many things, there is a trade-off.  
If you want to compare different parameter settings, you will have to do that consecutively. Set them, name the result, run the simulation, repeat. If you want to run many different parameter settings (parameter space exploration), then you will probably want to run the Digital_Coevolution simulation on a server or a cluster. Running many different parameter settings will take some time on a normal computer. Just refer to the next sections for running Digital_Coevolution on a server or cluster.  

```{r, eval = FALSE}
###########################################################
## In the lines below you can adjust some of the parameter 
## settings that influence the simulation

## Beware that combinations of large populations and 
## many replicates might overpower your computer.

# For how many time steps should the simulation run?
# It can help to think of that as days in the life 
# of a digital individual
duration.days <- 1000

# Here you can set how often a snapshot of all individuals 
# should be saved. Every N timesteps
saving.intervall <- 1

# How many replicates should there be?
replicates <- 1

###########################################################
## Here you can adjust the parameters that influence the 
## digital organisms themselves

# How many host populations should there be, and how large
# should they be? This doesn't directly set the number
# of individuals, but the resources that are available 
# per population. More resources will lead to larger 
# populations, but the exact number of individuals 
# that will result depends on many things.
host.populations <- c(100,100) 

# How many host genotypes should there be?
# Note that as default, each host genotype gets its own
# parasite genotype as well. 
host.genotypes <- 5

# Which proportion of the host populations should 
# randomly migrate each time step
host.migration <- 0

# Which proportion of the parasite populations
# should randomly migrate?
parasite.migration <- 0.5

# How genotype specific should the infection
# be in percent?
parasite.specificity <- 1

# How virulent should the parasites be?
# Virulence is implemented as percent resources withdrawn
# per time step, depending on infection size.
virulence <- 0.2 

# How much random drift should there be?
# Defined as proportion per timestep.
# This proportion of the host and the parasite population
# will additionally randomly be killed each timestep.
# A value of zero adds no additional random drift.
random.drift <- 0
```

The last thing you need to do in order to run the Digital_Coevolution simulation is simply to execute the whole script. If you already have executed all the parametersettings described above, you can simply execute the remaining lines of the script. Or to make things clean, source the whole script in a clean R session. Thats it, the simulation will start running, and notify you whence it is done.  

```{r, eval = FALSE}
###########################################################
## That's it. You have set all parameters. To run the 
## simulation either source this script or if you already 
## have executed the lines above, execute the remaining 
## lines as well.
###########################################################

###########################################################
## This sources a helper script that runs the simulation. 
print(paste("Simulation started :", Sys.time()))

source(file =  
         paste(source.file.location, "Digital_Coevolution_Run.R", sep = ""), 
       local = TRUE)
print("Congratulations, you have successfully run the Digital_Coevolution simulation. 
  Now go and check out those amazing results.")

print(paste("Simulation ended", Sys.time()))
``` 

### Getting the results
If you see the message: "Congratulations, you have successfully run the Digital_Coevolution simulation. Now go and check out those amazing results." on your screen, then you have successfully run the Digital_Coevolution simulation and you should go and check out those amazing results.  
The results will be three files in the folder that you have specified in the "_User" script as result.file.location. Two filenames will beginn with the name you have set in result.file.name, followed by "_Host_" or "_Parasite_", then the date on which the simulation was run, and finaly .csv, as the results are saved as simple comma separated values. These are the results from your simulation run. An example result file could be: "MyResult_Host_2020_02_14.csv". The third file that is generated is named "Digital_Coevolution_Parameters_run.date_result.file.name.RDS". That is a snapshot of the R environment at the beginning of the simulation, after all parameter settings have been made, but before the first loop of the simulation has run. It serves as a backup storage of the parameter settings of your run, should you need them at a later stage.  

\newpage

## Digital_Coevolution on a high performance cluster
### The cluster computing environment
The Digital_Coevolution simulation has been used extensively on a high performance cluster computer from ETH Zuerich, Euler. Cluster computers are powerfull aggregations of several (thousands) of computing nodes that are used for scientific calculations or other tasks that need lots of power. A single node is usually far more powerfull than an average home computer, harbouring multiple CPUs with mutliple cores and plenty of memory (RAM). Users will be able to get a subset of the cluster computer resources that fits their need. Usually, a user will submit a computing job that has specific requirements in terms of CPU cores and memory. Running several such jobs in parallel is what makes cluster computers so powerfull. As each job is independent, this is a great tool for parameterspace exploration, where you want to run the simulation with many different parameter settings.  
How a cluster computer can be used is dependent on the implementation of the cluster. In my use case of Euler cluster of ETH, the cluster runs on Unix and its resources are managed by an IBM LSF. LSF stands for load sharing facility and its the tool that distributes the available resources among the jobs requested by the users. The cluster itself can be accessed via entry nodes like a normal unix server, but running jobs on compute nodes can only be done via the LSF system. Access to the entry node is done via ssh from within the network. Your access system might differ.  

### Getting the Digital_Coevolution simulation to a cluster
Make sure that the cluster has R available on it. If it has not, please contact the adminstrator of your cluster, they will be able to help you.  
Getting the Digital_Coevoution simulation on the cluster is the easy part. Assuming that the entry node works like a standard unix server, you simply need to upload all the necessary files to a folder that can be acessed by you. You will need three R scripts: "Digital_Coevolution_Dynamics_Functions.R", "Digital_Coevolution_Parameterspace.R" and "Digital_Coevolution_Run_Unix.R", as well as one bash script: "Digital_Coevolution_User_Cluster.sh" and one .txt joblist file: "Digital_Coevolution_Joblist_Example.txt". In total you will need five files. Uploading to the cluster is done easiest when you already have downloaded those files from github to you local computer, and then transfer them to the cluster via scp. On windows you will need an extra programm to transfer files to a unix server, for example winscp. You will need to interact with several of the files before running the simulation, depending on your preferences it might be easier to modify them on your local machine before uploading (see next section).  

### Running the Digital_Coevoltution simulation on a cluster
Running the Digital_Coevolution simulation on a cluster is slightly different from running the simulation on your local machine. You will have to interact with three files instead of one.  
First you will need to interact with the "Digital_Coevolution_Run_Unix.R" file. In there you will need to set the paths to the folder on the cluster to where you have uploaded the scripts of the Digital_Coevolution simulation, the folder where you want the results, and a path to a fast scatch disk that can be used during the simulation.  
You can also set if you want raw results, summarized results, or both.  

```{r, eval = FALSE}
#############################################################
### Helper script for the Digital_Coevolution simulation ####
#############################################################
### High performance cluster computer version ####
##################################################
# Please type the full path to the folder that contains 
# the .R files, including this one.
source.file.location <- "/cluster/home/username/Digital_Coevolution/Scripts/"

# Please type the full path to the folder where results 
# should be saved.
final.result.location <- "/cluster/scratch/username/"

# Set the working directory for within loop saving to ultra fast scratch on cluster node
result.file.location <- "/scratch/"

# Here you can set if the results should be saved raw 
# or summarized or both, logical value FALSE or TRUE
raw.results <- FALSE
summarized.results <-TRUE

```

Next you will have to interact with the .txt file, the "Digital_Coevolution_Joblist_Example.txt". That is the file where you can set the parameters with which most will want to interact. Every line in the "Digital_Coevolution_Joblist_Example.txt" file is a sepparate, independent combination of parameters that will be run in an independent instance of the Digital_Coevolution simulation.  
The first line in the "Digital_Coevolution_Joblist_Example.txt" file are the names of the parameters that can be set. All those parameters are mandatory as they have no default settings (sorry). The order of those names in itself is irelevant, but the order of the parameter names in the first line, and the parameter values in all other lines needs to be the same.  
**IMPORTANT:** As the Digital_Coevolution simulation can simulate arbitrary numbers of host populations of arbitrary size, those need to be set explicitly. This means that you will need to add one parameter for each host population that you want to simulate. The names of these population parameters need necessarily to start with "host.population.". If you want to simulate five host populations, you will need to add five parameters with distinct names starting with "host.population.". Don't forget that you also need to set the parameter values of the respective host populations.  
All following lines are the respecive parameter values that correspond to the parameter names. The parameter values need to be in the same order than the parameter names.  
You can add several lines that contain parameter values to the joblist.txt file, each of which will result in a separate run of the Digital_Coevolution simulation with a different setting of parameters. Running a parameter space exploration can therefore easily be done by writing several lines into the "Digital_Coevolution_Joblist_Example.txt" file. If you have several lines in the joblist, you will be running a "job array", basically a list of jobs that you push to the cluster as one, but that the cluster will work on in a defined chunk size. You will need to know the number of parameter value lines for that. So all lines in the joblist file minus the first line containing the parameter names.  
Below you find an example of a joblist file containing two lines of parameter values.  

```{asis, eval = FALSE}
duration.days,saving.interval,replicates,host.population.1,host.population.2,
host.population.3,host.population.4,host.population.5,host.genotypes,host.migration,
parasite.migration,parasite.specificity,virulence,random.drift
250,25,5,50,50,50,50,50,5,0,0,1,0,0
250,25,5,50,50,50,50,50,5,0,0,1,0.4,0
``` 

The last file you will have to interact with is the bash script "Digital_Coevolution_User_Cluster.sh". Bash script? Right, for this user script you need to use bash, as most clusters (or at least the one I ran the simulation on) is running on unix.  
The first line in the bash script tell the interpreter that is is a bash script.  
The second and third line are used to set the maximum number of threads that can be used by the data.table package in R (which is used extensively in the simulation). This is an sensitive setting as it can produce varying results in different cluster environments. It is needed because data.table is capable of using multiple cores (or threads) natively. Data.table will automatically detect the number of cores available and use them accordingly. The number of cores or threads that data.table will detect can vary between systems and environments. On cluster computers there might eventually be the danger that data.table will detect all available cores on a node and not only the ones assigned to a job, and try to highjack them. This would lead to conflict and possibly the process being killed. In order to avoid that, the number of threads that data.table can detect is set explicitly. This at least is how I understood it and how I made it work.  
The next 7 lines that all beginn with a **#BSUB** string are intended for the LSF scheduler. The LSF scheduler distributes the clusters resources to the jobs that are requesting resources. All cluster resources that are specified there are valid per job, so each line from the joblist will have those resources available. If you request to little resources and your job requires more, it will usually be killed and cannot run to completion. If you repeatedly request way more resources than your job needs, your administrator will get angry at you. Usually, jobs that request more resources spend more time in the waiting queue before they get started. It is best practive though to request as little resources as possible but as much as needed.  
The dash and character (for example "-J") defines the use of the respective line.  
The line "-J" is the name of the job or job array. In the brackets you can specify the lines in the joblist that this job array should run over, usually all of the parameter value lines in the joblist. After the bracket you can specify the chunk size with which the cluster should work on the task array.  
The line "-R" is the space allocation, for both memory and scratch disk. In my bash script it is split in two lines for readability. The line with "-R" that reads "rusage[mem=1000]" is the memory allocation PER CORE, so the available RAM per job (one line in the joblist file) in mb. A value of 1000 means 1 GB of RAM per core.  
The line "-n" is the number of cores PER JOB. A value of two means that each job gets two cores.  
The line "-W" is the wall clock, meaning the available time that each job is allowed to run. The format is dd:hh:mm.  
The line "-R" is the space allocation, for both memory and scratch disk. In my bash script it is split in two lines for readability. The line with "-R" that reads "rusage[scratch=1000]" is the scratch disk allocation PER CORE, so the available discspace per job (one line in the joblist file) in mb. A value of 1000 means 1 GB of discspace per core. This is only the discspace on the ultra fast scratch disc directly on a computation node, and will not be available after the simulation ends.  
The line "-o" is the path and name of the output log file.  
The line "-e" is the path and name of the output error file.  

A bit further down are two lines starting with "newvars = ..." and "varid = ...", there you need to specify the path on the cluster to the folder where the "Digital_Coevolution_Joblist_Example.txt" is.  
Then follows a line starting with "resultname=..". There you specify the resultname.  
The "module load" line loads the R module on the cluster, this line you will have to modify with the respecitve module on your cluster.  
Finally there is the last line that starts with "Rscript", which starts the R session and where you need to specify the folder on the cluster where the R scripts are locaded.  

Those are a lot of things that you need to specify, and especially setting the requested resources right is not straightforward. But is is also not as hard as it sounds. Being able to leverage the power of cluster computing does greatly increase the scope of projects that can be tackled with the Digital_Coevolution simulation.  

```{bash, eval = FALSE}
#!/bin/bash 
export OMP_NUM_THREADS=2
export OMP_THREAD_LIMIT=2
#BSUB -J "Example_Jobname[1-14]%7"
#BSUB -R "rusage[mem=1000]" 
#BSUB -n 2
#BSUB -W 01:00
#BSUB -R "rusage[scratch=1000]" 
#BSUB -o /cluster/home/username/Digital_Coevolution/LogFiles/
Example_Jobname_username.log.%J.%I
#BSUB -e /cluster/home/username/Digital_Coevolution/ErrorFiles/
Example_Jobname_username.err.%J.%I

IDX=$LSB_JOBINDEX

newvars=`tail -n+$((IDX+1)) "/cluster/home/username/Digital_Coevolution/Scripts/
Digital_Coevolution_Joblist_Example.txt" | head -n1`
varid=`tail -n+1 "/cluster/home/username/Digital_Coevolution/Scripts/
Digital_Coevolution_Joblist_Example.txt" | head -n1`
resultname="Example_Jobname"

module load new gcc/4.8.2 r/3.6.0
Rscript "/cluster/home/username/Digital_Coevolution/Scripts/
Digital_Coevolution_Run_Unix.R" $varid $newvars $IDX $resultname

```

After having set all those things in the "Digital_Coevolution_Run_Unix.R", the "Digital_Coevolution_User_Cluster.sh" and the "Digital_Coevolution_Joblist_Example.txt" file, you will have to upload those files into the same folder on the cluster where the other three R scripts are. In order to start the job array on the cluster, you need to submit it. For this you will need to access the cluster, usually using ssh. On clusters using the IBM LSF, you will have to submit your job array to LSF in order to run it. It is depreciated to execute the bash script directly. Submitting the job array to LSF is done simply by navigating to the folder that contains the R and bash scripts and submitting the bash script "Digital_Coevolution_User_Cluster.sh" to bsub.  

```{bash, eval = FALSE}
bsub < Digital_Coevolution_User_Cluster.sh
``` 

Thats finally it. Your job is submitted to the queue and will be run soon. After the job is done, you will find the results in the folder that you have specified as final.result.folder in the "Digital_Coevolution_Run_Unix.R" script. The names and structure of the files is the same as described in the local use case above.  

--------------

\newpage

# Final remarks
Writing the Digital_Coevolution simulation has been great fun, and probably one of the most instructive experiences that I ever had. There is some truth in the saying that you have not understood something completely before you can not build it yourself. Trying to build this agent based simulation and reflecting how those agents have to behave lead me to have some great realisations on how complex and fascinating life is, and how little we actually understand. It made me read far more papers in a far broader aray of topics than I would have initially imagined, and I would not miss a bit of it.  
The Digital_Coevolution simulation is a purpose built tool that I have created to answer some questions in host parasite coevolution. By training I am a biologist, so writing this simulation has also been an experience in writing R. Therefore this has to be regarded as an amateur built piece of software. I am sure there are some mistakes in it. I hope that by providing the source code on github, some of those might be found. And I appologize already in advance, if in the future this simulation will not be updated as regularly, or if bugfixes and issues take a long time.  
Last but not least: Have fun, explore, stay curious.  

Cheers  
Robert

<br>


\newpage

# References

`r knitr::knit_exit()`

```{r}
      
##########################################################################################
```

### Run several parameters on your local machine
So you have succesfully run the Digital_Coevolution simulation a few times, gotten some cool results and now you are curious. You have a question in mind that needs to vary some of the parameters that you have set in the "Digital_Coevolution_User.R" script. You can run a (small) parameter space exploration on your local machine that automatically loop through a set of parameters. But beware, depending on your settings of population sizes, duration.days, replicates and others that might take some time.  
In order to do so, download the "Digital_Coevolution_Run_Euler.R" file into the same directory than all other Digital_Coevolution files and follow the directions of the below description of running the simulation on a server. Set your file path as usually and there you go.

## Digital_Coevolution on an unix server
### Getting the Digital_Coevolution simulation to your server
### Run a single  parameterset on an unix server
### Run several parameters on an unix server





\newpage
# References